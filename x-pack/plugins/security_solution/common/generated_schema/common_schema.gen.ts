/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import { z } from 'zod';

/*
 * NOTICE: Do not edit this file manually.
 * This file is automatically generated by the OpenAPI Generator `yarn openapi:generate`.
 */

export const CsvToArray = (value: unknown) => {
  if (typeof value === 'string') {
    return value.split(',');
  }
  return value;
};

export const FindRulesSortField = z.enum([
  'created_at',
  'createdAt',
  'enabled',
  'execution_summary.last_execution.date',
  'execution_summary.last_execution.metrics.execution_gap_duration_s',
  'execution_summary.last_execution.metrics.total_indexing_duration_ms',
  'execution_summary.last_execution.metrics.total_search_duration_ms',
  'execution_summary.last_execution.status',
  'name',
  'risk_score',
  'riskScore',
  'severity',
  'updated_at',
  'updatedAt',
]);
export type FindRulesSortField = z.infer<typeof FindRulesSortField>;

export const SortOrder = z.enum(['asc', 'desc']);
export type SortOrder = z.infer<typeof SortOrder>;

/**
   * Custom execution status of Security rules that is different from the status used in the Alerting Framework. We merge our custom status with the Framework's status to determine the resulting status of a rule.
- going to run - @deprecated Replaced by the 'running' status but left for backwards compatibility with rule execution events already written to Event Log in the prior versions of Kibana. Don't use when writing rule status changes.
- running - Rule execution started but not reached any intermediate or final status.
- partial failure - Rule can partially fail for various reasons either in the middle of an execution (in this case we update its status right away) or in the end of it. So currently this status can be both intermediate and final at the same time. A typical reason for a partial failure: not all the indices that the rule searches over actually exist.
- failed - Rule failed to execute due to unhandled exception or a reason defined in the business logic of its executor function.
- succeeded - Rule executed successfully without any issues. Note: this status is just an indication of a rule's "health". The rule might or might not generate any alerts despite of it.
   */
export const RuleExecutionStatus = z.enum([
  'going to run',
  'running',
  'partial failure',
  'failed',
  'succeeded',
]);
export type RuleExecutionStatus = z.infer<typeof RuleExecutionStatus>;

/**
   * Rule execution result is an aggregate that groups plain rule execution events by execution UUID.
It contains such information as execution UUID, date, status and metrics.
   */
export const RuleExecutionResult = z.object({
  execution_uuid: z.string(),
  timestamp: z.string().datetime(),
  duration_ms: z.number(),
  status: z.string(),
  message: z.string(),
  num_active_alerts: z.number(),
  num_new_alerts: z.number(),
  num_recovered_alerts: z.number(),
  num_triggered_actions: z.number(),
  num_succeeded_actions: z.number(),
  num_errored_actions: z.number(),
  total_search_duration_ms: z.number(),
  es_search_duration_ms: z.number(),
  schedule_delay_ms: z.number(),
  timed_out: z.boolean(),
  indexing_duration_ms: z.number(),
  search_duration_ms: z.number(),
  gap_duration_s: z.number(),
  security_status: z.string(),
  security_message: z.string(),
});
export type RuleExecutionResult = z.infer<typeof RuleExecutionResult>;

export const Action = z.object({
  /**
   * The action type used for sending notifications.
   */
  action_type_id: z.string(),
  /**
   * Optionally groups actions by use cases. Use `default` for alert notifications.
   */
  group: z.string(),
  /**
   * The connector ID.
   */
  id: z.string(),
  /**
   * Object containing the allowed connector fields, which varies according to the connector type.
   */
  params: z.object({}),
  uuid: z.string().optional(),
  /**
   * TODO implement the schema type
   */
  alerts_filter: z.object({}).optional(),
  /**
   * TODO implement the schema type
   */
  frequency: z.object({}).optional(),
});
export type Action = z.infer<typeof Action>;

export const AlertSuppression = z.object({
  group_by: z.array(z.string()).min(1).max(3),
  duration: z
    .object({
      value: z.number().min(1).optional(),
      unit: z.enum(['s', 'm', 'h']).optional(),
    })
    .optional(),
  missing_fields_strategy: z.enum(['doNotSuppress', 'suppress']).optional(),
});
export type AlertSuppression = z.infer<typeof AlertSuppression>;

export const BaseRule = z.object({
  /**
   * Rule name
   */
  name: z.string(),
  /**
   * Rule description
   */
  description: z.string(),
  /**
   * Risk score (0 to 100)
   */
  risk_score: z.number().min(0).max(100),
  /**
   * Severity of the rule
   */
  severity: z.enum(['low', 'medium', 'high', 'critical']),
  /**
   * Sets the source field for the alert's signal.rule.name value
   */
  rule_name_override: z.string().optional(),
  /**
   * Sets the time field used to query indices (optional)
   */
  timestamp_override: z.string().optional(),
  /**
   * Timeline template ID
   */
  timeline_id: z.string().optional(),
  /**
   * Timeline template title
   */
  timeline_title: z.string().optional(),
  outcome: z.enum(['exactMatch', 'aliasMatch', 'conflict']).optional(),
  /**
   * TODO
   */
  alias_target_id: z.string().optional(),
  /**
   * TODO
   */
  alias_purpose: z.enum(['savedObjectConversion', 'savedObjectImport']).optional(),
  /**
   * The rule’s license.
   */
  license: z.string().optional(),
  /**
   * Notes to help investigate alerts produced by the rule.
   */
  note: z.string().optional(),
  /**
   * Determines if the rule acts as a building block. By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts. Its value must be default.
   */
  building_block_type: z.string().optional(),
  /**
   * (deprecated) Has no effect.
   */
  output_index: z.string().optional(),
  /**
   * Has no effect.
   */
  namespace: z.string().optional(),
  /**
   * Stores rule metadata.
   */
  meta: z.object({}).optional(),
  /**
   * Defines the interval on which a rule's actions are executed.
   */
  throttle: z.string().optional(),
  /**
   * The rule’s version number. Defaults to 1.
   */
  version: z.number().min(1).optional().default(1),
  /**
   * String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
   */
  tags: z.array(z.string()).optional().default([]),
  /**
   * Determines whether the rule is enabled. Defaults to true.
   */
  enabled: z.boolean().optional().default(true),
  /**
   * Overrides generated alerts' risk_score with a value from the source event
   */
  risk_score_mapping: z
    .array(
      z.object({
        field: z.string(),
        operator: z.enum(['equals']),
        value: z.string(),
        risk_score: z.number().min(0).max(100).optional(),
      })
    )
    .optional()
    .default([]),
  /**
   * Overrides generated alerts' severity with values from the source event
   */
  severity_mapping: z
    .array(
      z.object({
        field: z.string(),
        operator: z.enum(['equals']),
        severity: z.enum(['low', 'medium', 'high', 'critical']),
        value: z.string(),
      })
    )
    .optional()
    .default([]),
  /**
   * Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
   */
  interval: z.string().optional().default('5m'),
  /**
   * Time from which data is analyzed each time the rule executes, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
   */
  from: z.string().optional().default('now-6m'),
  /**
   * TODO
   */
  to: z.string().optional().default('now'),
  actions: z.array(Action).optional().default([]),
  exceptions_list: z
    .array(
      z.object({
        /**
         * ID of the exception container
         */
        id: z.string().min(1),
        /**
         * List ID of the exception container
         */
        list_id: z.string().min(1),
        /**
         * The exception type
         */
        type: z.enum([
          'detection',
          'rule_default',
          'endpoint',
          'endpoint_trusted_apps',
          'endpoint_events',
          'endpoint_host_isolation_exceptions',
          'endpoint_blocklists',
        ]),
        /**
         * Determines the exceptions validity in rule's Kibana space
         */
        namespace_type: z.enum(['agnostic', 'single']),
      })
    )
    .optional()
    .default([]),
  author: z.array(z.string()).optional().default([]),
  false_positives: z.array(z.string()).optional().default([]),
  references: z.array(z.string()).optional().default([]),
  max_signals: z.number().min(1).optional().default(100),
  threat: z
    .array(
      z.object({
        /**
         * Relevant attack framework
         */
        framework: z.string().optional(),
        tactic: z
          .object({
            id: z.string().optional(),
            name: z.string().optional(),
            reference: z.string().optional(),
          })
          .optional(),
        technique: z
          .object({
            id: z.string().optional(),
            name: z.string().optional(),
            reference: z.string().optional(),
          })
          .optional(),
      })
    )
    .optional(),
  /**
   * Determines the query language (optional)
   */
  language: z.enum(['kuery', 'lucene']).optional(),
  /**
   * The query and filter context array used to define the conditions for when alerts are created from events (optional)
   */
  filters: z.array(z.object({})).optional(),
  /**
   * Indices on which the rule functions (optional)
   */
  index: z.array(z.string()).optional(),
});
export type BaseRule = z.infer<typeof BaseRule>;

export const QueryRule = BaseRule.and(
  z.object({
    /**
     * Rule type
     */
    type: z.enum(['query']),
    index: z.array(z.string()).optional(),
    data_view_id: z.string().optional(),
    filters: z.array(z.object({})).optional(),
    saved_id: z.string().optional(),
    /**
     * TODO
     */
    response_actions: z.array(z.object({})).optional(),
    alert_suppression: AlertSuppression.optional(),
    /**
     * Query to execute
     */
    query: z.string().optional().default(''),
    /**
     * Query language to use.
     */
    language: z.enum(['kuery', 'lucene']).optional().default('kuery'),
  })
);
export type QueryRule = z.infer<typeof QueryRule>;

export const SavedQueryRule = BaseRule.and(
  z.object({
    /**
     * Rule type
     */
    type: z.enum(['saved_query']),
    index: z.array(z.string()).optional(),
    data_view_id: z.string().optional(),
    filters: z.array(z.object({})).optional(),
    saved_id: z.string(),
    /**
     * TODO
     */
    response_actions: z.array(z.object({})).optional(),
    alert_suppression: AlertSuppression.optional(),
    /**
     * Query to execute
     */
    query: z.string().optional().default(''),
    /**
     * Query language to use.
     */
    language: z.enum(['kuery', 'lucene']).optional().default('kuery'),
  })
);
export type SavedQueryRule = z.infer<typeof SavedQueryRule>;

export const ThresholdRule = BaseRule.and(
  z.object({
    /**
     * Rule type
     */
    type: z.enum(['threshold']),
    query: z.string(),
    threshold: z.object({
      /**
       * Field to aggregate on
       */
      field: z.union([z.string(), z.array(z.string())]),
      /**
       * Threshold value
       */
      value: z.number().min(1).optional(),
      cardinality: z
        .array(
          z.object({
            field: z.string().optional(),
            value: z.number().min(0).optional(),
          })
        )
        .optional(),
    }),
    index: z.array(z.string()).optional(),
    data_view_id: z.string().optional(),
    filters: z.array(z.object({})).optional(),
    saved_id: z.string().optional(),
    /**
     * Query language to use.
     */
    language: z.enum(['kuery', 'lucene']).optional().default('kuery'),
  })
);
export type ThresholdRule = z.infer<typeof ThresholdRule>;

export const ThreatMatchRule = BaseRule.and(
  z.object({
    /**
     * Rule type
     */
    type: z.enum(['threat_match']),
    query: z.string(),
    /**
     * Query to execute
     */
    threat_query: z.string(),
    threat_mapping: z
      .array(
        z.object({
          entries: z
            .array(
              z.object({
                field: z.string().min(1).optional(),
                type: z.enum(['mapping']).optional(),
                value: z.string().min(1).optional(),
              })
            )
            .optional(),
        })
      )
      .min(1),
    threat_index: z.array(z.string()),
    index: z.array(z.string()).optional(),
    data_view_id: z.string().optional(),
    filters: z.array(z.object({})).optional(),
    saved_id: z.string().optional(),
    threat_filters: z.array(z.object({})).optional(),
    /**
     * Defines the path to the threat indicator in the indicator documents (optional)
     */
    threat_indicator_path: z.string().optional(),
    /**
     * Query language to use.
     */
    threat_language: z.enum(['kuery', 'lucene']).optional().default('kuery'),
    concurrent_searches: z.number().min(1).optional(),
    items_per_search: z.number().min(1).optional(),
    /**
     * Query language to use.
     */
    language: z.enum(['kuery', 'lucene']).optional().default('kuery'),
  })
);
export type ThreatMatchRule = z.infer<typeof ThreatMatchRule>;

export const MlRule = BaseRule.and(
  z.object({
    /**
     * Rule type
     */
    type: z.enum(['machine_learning']),
    /**
     * Anomaly threshold
     */
    anomaly_threshold: z.number().min(0),
    /**
     * Machine learning job ID
     */
    machine_learning_job_id: z.union([z.string(), z.array(z.string()).min(1)]),
  })
);
export type MlRule = z.infer<typeof MlRule>;

export const EqlRule = BaseRule.and(
  z.object({
    /**
     * Rule type
     */
    type: z.enum(['eql']),
    language: z.enum(['eql']),
    /**
     * EQL query to execute
     */
    query: z.string(),
    index: z.array(z.string()).optional(),
    data_view_id: z.string().optional(),
    filters: z.array(z.object({})).optional(),
    /**
     * Contains the event classification
     */
    event_category_field: z.string().optional(),
    /**
     * Sets a secondary field for sorting events
     */
    tiebreaker_field: z.string().optional(),
    /**
     * Contains the event timestamp used for sorting a sequence of events
     */
    timestamp_field: z.string().optional(),
  })
);
export type EqlRule = z.infer<typeof EqlRule>;

export const NewTermsRule = BaseRule.and(
  z.object({
    /**
     * Rule type
     */
    type: z.enum(['new_terms']),
    query: z.string(),
    new_terms_fields: z.array(z.string()).min(1).max(3),
    history_window_size: z.string().min(1).optional(),
    index: z.array(z.string()).optional(),
    data_view_id: z.string().optional(),
    filters: z.array(z.object({})).optional(),
    language: z.enum(['kuery', 'lucene']).optional().default('kuery'),
  })
);
export type NewTermsRule = z.infer<typeof NewTermsRule>;

export const Rule = z.union([
  QueryRule,
  SavedQueryRule,
  ThresholdRule,
  ThreatMatchRule,
  MlRule,
  EqlRule,
  NewTermsRule,
]);
export type Rule = z.infer<typeof Rule>;

/**
 * Defines the maximum interval in which a rule's actions are executed.
 */
export const Throttle = z.enum(['rule', '1h', '1d', '7d']);
export type Throttle = z.infer<typeof Throttle>;

export const Subtechnique = z.object({
  /**
   * Subtechnique ID
   */
  id: z.string(),
  /**
   * Subtechnique name
   */
  name: z.string(),
  /**
   * Subtechnique reference
   */
  reference: z.string(),
});
export type Subtechnique = z.infer<typeof Subtechnique>;

export const Technique = z.object({
  /**
   * Technique ID
   */
  id: z.string(),
  /**
   * Technique name
   */
  name: z.string(),
  /**
   * Technique reference
   */
  reference: z.string(),
  /**
   * Array containing more specific information on the attack technique
   */
  subtechnique: z.array(Subtechnique).optional(),
});
export type Technique = z.infer<typeof Technique>;

export const Threat = z.object({
  /**
   * Relevant attack framework
   */
  framework: z.string(),
  tactic: z.object({
    /**
     * Tactic ID
     */
    id: z.string().optional(),
    /**
     * Tactic name
     */
    name: z.string().optional(),
    /**
     * Tactic reference
     */
    reference: z.string().optional(),
  }),
  /**
   * Array containing information on the attack techniques (optional)
   */
  technique: z.array(Technique).optional(),
});
export type Threat = z.infer<typeof Threat>;

export const BulkActionBase = z.union([
  z.object({
    /**
     * Query to filter rules
     */
    query: z.string(),
  }),
  z.object({
    /**
     * Array of rule IDs
     */
    ids: z.array(z.string()).min(1).optional(),
  }),
]);
export type BulkActionBase = z.infer<typeof BulkActionBase>;

export const BulkDeleteRules = BulkActionBase.and(
  z.object({
    action: z.enum(['delete']),
  })
);
export type BulkDeleteRules = z.infer<typeof BulkDeleteRules>;

export const BulkDisableRules = BulkActionBase.and(
  z.object({
    action: z.enum(['disable']),
  })
);
export type BulkDisableRules = z.infer<typeof BulkDisableRules>;

export const BulkEnableRules = BulkActionBase.and(
  z.object({
    action: z.enum(['enable']),
  })
);
export type BulkEnableRules = z.infer<typeof BulkEnableRules>;

export const BulkExportRules = BulkActionBase.and(
  z.object({
    action: z.enum(['export']),
  })
);
export type BulkExportRules = z.infer<typeof BulkExportRules>;

export const BulkDuplicateRules = BulkActionBase.and(
  z.object({
    action: z.enum(['duplicate']),
    duplicate: z
      .object({
        /**
         * Whether to copy exceptions from the original rule
         */
        include_exceptions: z.boolean().optional(),
        /**
         * Whether to copy expired exceptions from the original rule
         */
        include_expired_exceptions: z.boolean().optional(),
      })
      .optional(),
  })
);
export type BulkDuplicateRules = z.infer<typeof BulkDuplicateRules>;

/**
 * Action summary indicates whether we will send a summary notification about all the generate alerts or notification per individual alert
 */
export const RuleActionSummary = z.boolean();
export type RuleActionSummary = z.infer<typeof RuleActionSummary>;

/**
 * The condition for throttling the notification: 'onActionGroupChange', 'onActiveAlert',  or 'onThrottleInterval'
 */
export const RuleActionNotifyWhen = z.enum([
  'onActionGroupChange',
  'onActiveAlert',
  'onThrottleInterval',
]);
export type RuleActionNotifyWhen = z.infer<typeof RuleActionNotifyWhen>;

/**
 * The condition for throttling the notification: 'rule', 'no_actions', or time duration
 */
export const RuleActionThrottle = z.string();
export type RuleActionThrottle = z.infer<typeof RuleActionThrottle>;

export const RuleActionFrequency = z.object({
  summary: RuleActionSummary.optional(),
  notifyWhen: RuleActionNotifyWhen.optional(),
  throttle: RuleActionThrottle.nullable().optional(),
});
export type RuleActionFrequency = z.infer<typeof RuleActionFrequency>;

export const BulkActionEditPayloadRuleActions = z.object({
  type: z.enum(['add_rule_actions', 'set_rule_actions']),
  value: z.object({
    throttle: RuleActionThrottle.optional(),
    actions: z
      .array(
        z.object({
          /**
           * Action group
           */
          group: z.string(),
          /**
           * Action ID
           */
          id: z.string(),
          /**
           * Action parameters
           */
          params: z.object({}),
          /**
           * Action frequency
           */
          frequency: RuleActionFrequency.optional(),
        })
      )
      .optional(),
  }),
});
export type BulkActionEditPayloadRuleActions = z.infer<typeof BulkActionEditPayloadRuleActions>;

export const BulkActionEditPayloadSchedule = z.object({
  type: z.enum(['set_schedule']).optional(),
  value: z
    .object({
      /**
       * Interval in which the rule is executed
       */
      interval: z.string().optional(),
      /**
       * Lookback time for the rule
       */
      lookback: z.string().optional(),
    })
    .optional(),
});
export type BulkActionEditPayloadSchedule = z.infer<typeof BulkActionEditPayloadSchedule>;

export const BulkActionEditPayload = z.union([
  BulkActionEditPayloadRuleActions,
  BulkActionEditPayloadSchedule,
]);
export type BulkActionEditPayload = z.infer<typeof BulkActionEditPayload>;

export const BulkEditRules = BulkActionBase.and(
  z.object({
    action: z.enum(['edit']),
    /**
     * Array of objects containing the edit operations
     */
    edit: z.array(BulkActionEditPayload).optional(),
  })
);
export type BulkEditRules = z.infer<typeof BulkEditRules>;

export const PerformBulkActionRequest = z.union([
  BulkDeleteRules,
  BulkDisableRules,
  BulkEnableRules,
  BulkExportRules,
  BulkDuplicateRules,
  BulkEditRules,
]);
export type PerformBulkActionRequest = z.infer<typeof PerformBulkActionRequest>;
